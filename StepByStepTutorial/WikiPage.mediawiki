= Step by step tutorial to create extensions =

''Phrases or words in bigger need to be reviewed to ensure that is correct''

''To review''

[[#toReview-1]]
[[#toReview-2]]
[[#toReview-3]]
[[#toReview-4]]
[[#toReview-5]]

<<Anchor(index)>>
 * [[#fromScratch | From scratch]]
   * [[#fromScratch-settingUpEclipse | Setting up eclipse]]
   * [[#fromScratch-settingUpEclipse-problems | Problems setting up eclipse]]
   * [[#fromScratch-usingEclipse|Using eclipse]]
 * [[#knowingJavascript | Knowing javascript for gnome-shell]]
   * [[#knowingJavascript-introducingJavascript | Introducing javascript]]
   * [[#knowingJavascript-howExtends|How extends functionality]]
 * [[#knowingClutter|Knowing clutter]]
   * [[#knowingClutter-introducingClutter|Introducing clutter]]
   * [[#knowingClutter-signals|Signals]]
   * [[#knowingClutter-someExamples|Some examples with raw clutter]]
     *[[#knowingClutter-someExamples-init | Init clutter and stage]]
     *[[#knowingClutter-someExamples-draw | Draw something]]
     *[[#knowingClutter-someExamples-signals | Add some signals to make it interactive]]
     *[[#knowingClutter-someExamples-animate | Animations]]
     *[[#knowingClutter-someExamples-game | Game with all together]]
   * [[#knowingClutter-problems | Problems]]
 * [[#knowingGnomeShell|Knowing gnome-shell]]
   * [[#knowingGnomeShell-introducing|Introducing gnome shell]]
   * [[#knowingGnomeShell-interactionWithClutter|Interaction with clutter]]
   * [[#knowingGnomeShell-API|API]]
 * [[#lookingGlass|Looking glass]]
 * [[#myFirstExtension | My first extension]]
 * [[#errorsAndDebug | How to know your errors and debug your code]]
   * [[#errorsAndDebug-knowYourErrors|Know your errors]]
   * [[#errorsAndDebug-redirectOutput|Redirect output to error console]]
 * [[#interestingClasses | Accessing some interesting objects of gnome-shell]]
 * [[#extensionExamples | Some extensions examples]]
   * [[#extensionExamples-extensionUsingDash|Extension using dash]]
   * [[#extensionExamples-extensionUsingWindows|Extension using windows]]
   * [[#extensionExamples-extensionUsingWorkspace|Extension using workspace]]
   * [[#extensionExamples-extensionUsingApplications|Extension using applications]]
   * [[#extensionExamples-extensionUsingMessageTray|Extension using message tray]]
   * [[#extensionExamples-extensionUsingTopBar|Extension using top bar]]
 * [[#allCode | All code to download or modify]]
 * [[#support | Support]]

<<Anchor(fromScratch)>>
= From scratch =
<<Anchor(fromScratch-settingUpEclipse)>>
== Setting up eclipse ==
<<Anchor(fromScratch-settingUpEclipse-whyUseAnIde)>>
=== Why use an IDE ===

It is very helpful to develop using an IDE with javascript support. It will help us with code folding, autocompletion, outline, etc.

Gnome has his own IDE for develop, called Anjuta. The problem is that IDE has some feature lacks, like autocompletion, code folding, etc... so for me it is better to develop using eclipse until anjuta envolves to have this kind of features.

So, we start setting up eclipse to have javascript support.

Setting up eclipse

Install eclipse from your app store of your distribution. Open eclipse and select your workspace Go to Help->Install new software Select Work with "All available sites" Search for javascript Install That's it!
<<Anchor(fromScratch-settingUpEclipse-problems)>>
=== Problems ===

I haven't got eclipse in my distribution
Go to http://www.eclipse.org/downloads/ and download eclipse classic.
I select work with "All avaiable sites" but nothing is shown
Go to "Find more software by working with "All available software sites" preferences" and add your eclipse download site, that it depens on the eclipse version you have. For eclipse Juno it is http://download.eclipse.org/releases/juno

[[#index | Go to index]]

<<Anchor(fromScratch-usingEclipse)>>
== Using eclipse ==

When you create an extension, the extension is saved at ~/.local/shared/gnome-shell/extensions with a gnome-shell extension folder format, so you can't create a project here and edit the files expecting that each change you do reflects directly in the gnome-shell. So, for use eclipse to develop extensions, the best way is to open directly the file you are editing, like ~/.local/shared/gnome-shell/extensions/myExtensionFolder/myExtension.js

To visualize the changes you have to have enabled the extension. To enable the extension use gnome-tweak-tool.

After that, each change yo do you have to save the file and restart the shell (Alt+F2 , write "r" without quotes, enter)

[[#index | Go to index]]

<<Anchor(knowingJavascript)>>
= Knowing javascript for gnome-shell =

<<Anchor(knowingJavascript-introducingJavascript)>>
== Introducing javascript ==
JavaScript (sometimes abbreviated JS) is a prototype-based scripting language that is dynamic, weakly typed and has first-class functions. It is a multi-paradigm language, supporting object-oriented, imperative, and functional programming styles.

Gnome-shell is written in javascript because it allows a quick prototyping. It means that it allows to change the code quickly, and do a lot of changes in a easy way. It is needed because gnome-shell is a application that is in a quick development, and it changes a lot in short time.
<<Anchor(toReview-1)>>
The diference between javascript and other dynamic languages (python, ruby, php, etc...) is that javascript doesn't depends in a specific platform, so ~+gnome-shell can run it without any platform under it +~.

This is an extended web page about programming in javascript (web oriented). Some things changes because we are not programming for the web, but most is the same. There's the web:
https://developer.mozilla.org/en-US/learn/javascript

Quick characteristic things:
<<Anchor(toReview-2)>>
 * ~+ Classes, objects, variables, functions is less or more the same. +~
 * To access some function or variable: object.function() / object.variable or object.function() / object['function']()
<<Anchor(toReview-3)>>
 * ~+ You can modify the code while running +~
 * class.prototype allow you inheritance or modify the base class directly rewriting his code.
 * Variables without scope. So, if you do "var x", x will be in all of your program. The only way to restrict the scope is "let x" that make the variable x only usable in his scope.
 * If we want to use "this" outside of his scope we need the class Lang. The use is in this way: functionOutsideOfScope(Lang.bind(this, this.function())). See https://live.gnome.org/GnomeShell/Gjs_StyleGuide ""this" in closures" to see one example.

[[#index | Go to index]]

<<Anchor(knowingJavascript-howExtends)>>
== How extends functionality ==

'' Don't do anything until we arrive to the extensions headland, because you don't know how to create, enable and some importants parts of an extension''

The main way to extend functionality is rewritten the code of the gnome-shell in this way:
We have a class called Workspace (File: /usr/share/gnome-shell/js/ui/Workspace. The class is something like this:
{{{#!java
const Workspace = new Lang.Class({
    Name: 'Workspace',

    _init : function(metaWorkspace, monitorIndex) {
        // When dragging a window, we use this slot for reserve space.
        this._reservedSlot = null;
        this.metaWorkspace = metaWorkspace;
etc...

_lookupIndex: function (metaWindow) {
        for (let i = 0; i < this._windows.length; i++) {
            if (this._windows[i].metaWindow == metaWindow) {
                return i;
            }
        }
        return -1;
    },
})
}}}

And we want to modify the _lookupIndex to return always 1. So we do this in our extension:

{{{#!java
Workspace.prototype['_lookupIndex'] = function (metaWindow){ return 1; }
}}}

As we saw in the Javascript attachment paper, we can modify the base class editting his "prototype". To access some function, object, variable, etc. we put the name of the function/variable/object/etc bracketed in a string format. In the right side of equal, we write our function that we want to replace the function of the left side.

After enabling our extension and restarting the shell, if we execute the Workspace._lookupIndex function, we get always 1 in return value.

Another way to extend funcionality is to injecting code, with this function:
{{{#!java
function injectToFunction(parent, name, func)
{
	let origin = parent[name];
	parent[name] = function()
	{
		let ret;
		ret = origin.apply(this, arguments);
		if (ret === undefined)
			ret = func.apply(this, arguments);
		return ret;
	}
	return origin;
}

function removeInjection(object, injection, name)
{
	if (injection[name] === undefined)
		delete object[name];
	else
		object[name] = injection[name];
}

}}}

And to inject some code in a function use this in this way:

{{{#!java
//We store the injection, for after have the option to dissable the injection.
inections=[];
injections['injectionOfLookupIndex']=injectToFunction(Workspace.prototype, '_lookupIndex',  function(){return 1;});
}}}

And to desinject the code

{{{#!java
removeInjection(Workspace.prototype, injections,  'injectionOfLookupIndex');
}}}

<<Anchor(toReview-4)>>
With this, we can add some code to the function without rewriting all the function. Our code is write ~+ before the return statement of the original function and after all code of original function+~

We'll see why we need to desinject the code in "my first extensions" headland.

[[#index | Go to index]]

<<Anchor(knowingClutter)>>
= Knowing clutter =

<<Anchor(knowingClutter-introducingClutter)>>
== Introducing clutter ==

Clutter is a C programming API that allows you to create simple but visually appealing and involving user interfaces. It offers a variety of objects (actors) which can be placed on a canvas (stage) and manipulated by the application or the user. It is therefore a "retained mode" graphics API. Unlike traditional 2D canvas APIs, Clutter allows these actors to move partly in the Z dimension.
It is used by gnome-shell to implement all the GUI of gnome-shell.

There's three tecnologies that allow us to use easily clutter with javascript:

<<Anchor(toReview-5)>>
Clutter use [[https://live.gnome.org/GObjectIntrospection | GObjectIntrospection]], project that allows to use c programs from other programming languages directly and it allows us to work in javascript with it, instead of using c. ~+It works transforming the c program API in general files(xml or custom files) allowing to write easily a binding in other program language that can interpret it.+~

From that, we need a program that get the general file result from GObjectIntrospection and transform it to a specific program language, like javascript. This program is specific for each program language, an for javascript it is called [[https://live.gnome.org/Gjs | Gjs]].

Also, gnome-shell has his own clutter-based toolkit, called [[http://developer.gnome.org/st/stable/ | St]], that give you some useful actors(components in the GUI). Also St is the way for gnome-shell to interact with CSS theming; so the form
and color of every button, dialog etc. of gnome shell is defined in /usr/share/gnome-shell/theme, and the only class that
manage this css is St.


So we have:
Clutter in c -> GObjectIntrospection(result in a generl file) ->
 * -> Gjs(interprets general file from GObjectIntrospection to javascript)
 * -> pyclutter (interprets general file from GObjectIntrospection to python)
 * -> clutter-perl (interprets general file from GObjectIntrospection to perl)
 * -> etc.

All bindings: http://www.clutter-project.org/about/language-bindings

Important characteristic things in clutter is:
 * Stage: contain some actors(text, rectangles etc). It's the window of the application. Also is an actor.
 * Actor: GUI object
   * show() : you have to show each actor to be visible to the user
   * hide() : hide the actor

[[#index | Go to index]]

<<Anchor(knowingClutter-events)>>
== Events ==

We need events to do the GUI interactive and reactive to mouse clicks and keyboard inputs.
also, we can use custom events inside our program, to communicate by events functions in our program.

By default, each actor in clutter has these events:
 * button-press-event: Emitted when the user presses the mouse over the actor.
 * button-release-event: Emitted when the user releases the mouse over the actor.
 * motion-event: Emitted when the user moves the mouse over the actor.
 * enter-event: Emitted when the user moves the mouse in to the actor's area.
 * leave-event: Emitted when the user moves the mouse out of the actor's area.
All events:
http://docs.clutter-project.org/docs/clutter/stable/ClutterActor.html
And look at the bottom, there is all the events emitted by the actor.
 
We can associate each event with one actor and a function that will be called when the event occurs to do
what we want to do when the event occurs(like move the actor when we click it, change his opacity when we hover it, etc.)
This association is called "connect".

So, to connect one actor to one event:
actor.connect(eventName, functionToCallWhenEventOccurs);

For example:
{{{#!java
//Create new actor
actor=new Clutter.Actor();
/*
 * Connect the actor to the enter-event and it will call moveActor function when
 * we click the actor
*/
actor.connect('enter-event', moveActor);

/*
 * Automatically, the enter event pass some parameters to the function.
 * these parameters are the event and the actor.
 * http://docs.clutter-project.org/docs/clutter/stable/ClutterActor.html
 * in the document above, search for "The "leave-event" signal"
*/
function  moveActor(actor, event)
{
    let x=0;
    let y=2;
    //Set the new position to the actor.
    actor.set_position(x, y);
}
}}}

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples)>>
== Some examples with raw clutter ==

<<Anchor(knowingClutter-someExamples-init)>>
=== Init clutter and stage ===
{{{#!java
//Import the clutter class form the gi repository(the object introspection repository)
const Clutter = imports.gi.Clutter;
// Initialize clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object so many of that
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the mainloop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some title
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 150,
    blue : 0,
    green : 0,
    alpha : 255
}));
// As we say, the stage is also an actor, so we shoe it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();
}}}

Save this code to a file "InitClutterAndStage.js" and to execute we enter in a terminal:
{{{
gjs-console InitClutterAndStage.js
}}}
As you see we are using gjs to execute the file, so you have to have Gjs installed
(search for Gjs in your software management application)

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples-draw)>>
=== Draw something ===

Now we try to draw a rectangle in the stage
{{{#!java
//Import the clutter class form the gi repository(the object introspection repository)
const Clutter = imports.gi.Clutter;
// Initialize clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object so many of that
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the mainloop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some title
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 10,
    blue : 10,
    green : 10,
    alpha : 255
}));

// Create a new actor
let actorRectangle = new Clutter.Actor();
// Make it like a rectangle
actorRectangle.set_size(100, 100);
actorRectangle.set_position(100, 100);
/*
 * Colors are made in RGBA http://en.wikipedia.org/wiki/RGBA_color_space
 * Basically, Red, Green, Blue, Alpha(transparency). Each factor, between 0-255
 */
actorRectangle.set_background_color(new Clutter.Color({
    red : 100,
    blue : 100,
    green : 100,
    alpha : 255
}));

stage.add_actor(actorRectangle);
// As we say, the stage is also an actor, so we shoe it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();
}}}

Save this code to a file "DrawSomething.js" and to execute we enter in a terminal:
{{{
gjs-console DrawSomething.js
}}}

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples-signals)>>
=== Add some signals to make it interactive ===

Now, we do something funny. We will add a hover event to the rectangle actor, and each time
we hover the actor, the actor will change the position randomly.

{{{#!java
//Import the clutter class form the gi repository(the object introspection repository)
const Clutter = imports.gi.Clutter;

// Initialize clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object so many of that
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the mainloop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some title
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 10,
    blue : 10,
    green : 10,
    alpha : 255
}));

// Create a new actor
let
actorRectangle = new Clutter.Actor();
// Put his x, y size, position and background color
actorRectangle.set_size(100, 100);
actorRectangle.set_position(100, 100);
actorRectangle.set_background_color(new Clutter.Color({
    red : 100,
    blue : 100,
    green : 100,
    alpha : 255
}));

// Sets actor as reactive. Reactive actors will receive events.
actorRectangle.set_reactive(true);
/*
 * Connect the actor to a event. When you hover it, function in the second
 * parameter will be called. So we are passing a reference to a function.
 */
actorRectangle.connect('enter-event', changeRectanglePosition);

stage.add_actor(actorRectangle);
// As we say, the stage is also an actor, so we show it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();

function changeRectanglePosition()
{
    // We get the size of the stage(our window)
    let [sizex, sizey] = stage.get_size();
    /*
     * Math.random return a float between 0 and 1, so we multiply by the size of
     * the stage and we acomplish a number between 0-sizeStage
     */
    let newx = Math.floor(Math.random() * sizex);
    let newy = Math.floor(Math.random() * sizey);
    /*
     * We can access to that because is a global variable. Also, remember that
     * with "let" the scope is the block and with "var" the scope is all the
     * environment. In this case,the block is all the environment We put the new
     * random position
     */
    actorRectangle.set_position(newx, newy);
}
}}}

Save this code to a file "ClutterEvents.js" and to execute we enter in a terminal:
{{{
gjs-console ClutterEvents.js
}}}

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples-animate)>>
=== Animations ===

Now, we add an animation to the actor. This animation only will start each
time we hover the actor. So we have to put the animation inside the function
we call when hover the actor.

{{{#!java
//Import the clutter class form the gi repository(the object introspection repository)
const
Clutter = imports.gi.Clutter;

// Initialice clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object so many of that
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the mainloop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some title
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 10,
    blue : 10,
    green : 10,
    alpha : 255
}));

// Create a new actor
let actorRectangle = new Clutter.Actor();
// Put his x, y size, position and background color
actorRectangle.set_size(100, 100);
actorRectangle.set_position(100, 100);
actorRectangle.set_background_color(new Clutter.Color({
    red : 100,
    blue : 100,
    green : 100,
    alpha : 255
}));

// Sets actor as reactive. Reactive actors will receive events.
actorRectangle.set_reactive(true);
/*
 * Connect the actor to a event. When you hover it, function in the second
 * parameter will be called. So we are passing a reference to a function.
 */
actorRectangle.connect('enter-event', changeRectanglePosition);
// Add the rectangle to the stage
stage.add_actor(actorRectangle);

// As we say, the stage is also an actor, so we show it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();

function changeRectanglePosition()
{
    // We get the size of the stage(our window)
    let [sizex, sizey] = stage.get_size();
    /*
     * Math.random return a float between 0 and 1, so we multiply by the size of
     * the stage and we acomplish a number between 0-sizeStage
     */
    let newx = Math.floor(Math.random() * sizex);
    let newy = Math.floor(Math.random() * sizey);
    /*
     * We can access to that because is a global variable. Also, remember that
     * with "let" the scope is the block and with "var" the scope is all the
     * environment. In this case,the block is all the environment We put the new
     * random position
     */
    actorRectangle.set_position(newx, newy);

    /*
     * WARNING: The next code is deprectaed since clutter 1.6, but we don't have
     * even the easy way to animate actors in raw clutter in stable version of
     * fedora 17, so we use deprecated code. The easy way in new code is:
     * actorRectangle.animate(Clutter.AnimationMode.EASE_OUT_ELASTIC, 500,
     * "scale-x", 0.5, "scale-y", 0.5, NULL); New code to animate actors:
     * http://docs.clutter-project.org/docs/clutter/stable/clutter-Implicit-Animations.html
     */

    /*
     * To animate an actor we need three things timeline: think about it like
     * play, pause and stop and bar time of your videos alpha: how is made the
     * transition, because we can made a tansition bounding, quickly at first
     * and later slowly, etc. There are all the transitions:
     * http://docs.clutter-project.org/docs/clutter/stable/clutter-Implicit-Animations.html#ClutterAnimationMode
     * behaviour: what property of the actor we want to animate, scale, opacity,
     * etc. each property has his own class, behaviourScale, behaviourOpacity,
     * etc. all properties of behaviourScale:
     * http://docs.clutter-project.org/docs/clutter/stable/ClutterBehaviourScale.html
     */
    let timeline = new Clutter.Timeline({
        'duration' : 500
    });
    let alpha = new Clutter.Alpha({
        'timeline' : timeline,
        'mode' : Clutter.AnimationMode.EASE_OUT_ELASTIC
    });
    let behaviourScale = new Clutter.BehaviourScale({
        'alpha' : alpha,
        'x_scale_start' : 1.0,
        'y_scale_start' : 1.0,
        'x_scale_end' : 0.5,
        'y_scale_end' : 0.5
    });
    behaviourScale.apply(actorRectangle);
    timeline.start();
}
}}}

Save this code to a file "ClutterAnimations.js" and to execute we enter in a terminal:
{{{
gjs-console ClutterAnimations.js
}}}

<<Anchor(knowingClutter-someExamples-game)>>
=== Game with all together ===

Now we will do something funny, a (in Spanish, it is called "3 en raya") game.
In this game we will have objects painted, events and animations.
We need a board, two players, and two types of tokens.
It suposed that you already has read the previous headlands about clutter.

We need two classes, GameBoard, that define the program behaviour and data and Gameosx that define the GUI with clutter.

Class GameBoard:

{{{#!java
/*
 * Code from http://townx.org/blog/elliot/introduction-sorts-javascript-desktop-application-development-gjs-and-clutter
 * Commented and update to clutter 1.10 by Carlos Soriano
 */

/*
 * Define what is a square in the game
 * We use this way to define a class,
 * using the prototype.
 * @see <a href="http://www.phpied.com/3-ways-to-define-a-javascript-class/"> Ways to define a "class" in JS
 */

/**
 * Class to define a square to play in the board This "class" use the method
 * prototype to do define a "class" in javascript</a>
 * 
 * @constructor
 * @param {Integer}
 *                x - position x of the square. For normal use, 0 to 2
 * @param {Integer}
 *                y - position y of the square. for normal use, 0 to 2
 */
function Square(x, y, player) {
    this.player = player;
    this.x = x;
    this.y = y;
};

Square.prototype = {
        getPlayer : function () {
            return this.player;
        },

        setPlayer : function (player) {
            this.player = player;
        },

        getX : function () {
            return this.x;
        },

        getY : function () {
            return this.y;
        }
};


/**
 * Class to define the line drawn when some player won
 * 
 * @constructor
 */
function Line () {
    this.squares = [];
};

Line.prototype = {
        first : function () {
            return this.squares[0];
        },

        last : function () {
            return this.squares[this.squares.length - 1];
        },

        addSquare : function (square) {
            this.squares.push(square);
        },

        winsFor : function () {
            let current = null;
            let last = null;

            for (let i = 0; i < this.squares.length; i++) {
                current = this.squares[i].getPlayer();
                if (i > 0 && current != last) {
                    last = null;
                    break;
                }
                else {
                    last = current;
                }
            }
            return last;
        },

        clear : function () {
            this.squares = [];
        }
};

/**
 * Class to definethe board of the game
 * 
 * @constructor
 * @param {Integer} players - The count of the players
 * @param {Integer} sideSize - The quantity of squares can have the board in a side
 */

function Board(players, sideSize) {
    this._init(players, sideSize);
};

Board.prototype = {

        _init : function(players, sideSize) {
            this.squares = [];
            this.sideSize = sideSize;
            this.winner = null;
            this.playerPos = 0;
            this.players = players;

            for (var i = 0; i < sideSize; i++) {
                this.squares[i] = [];
                for (var j = 0; j < sideSize; j++) {
                    this.squares[i][j] = new Square(i, j, null);
                }
            }
        },

        switchPlayer : function() {
            this.playerPos = this.playerPos + 1;
            if (this.playerPos >= this.players.length) {
                this.playerPos = 0;
            }
        },

        getNextPlayer : function() {
            return this.players[this.playerPos];
        },

        makeMove : function(x, y, player) {
            this.squares[x][y].setPlayer(player);
            let line = this.getWinningLine();
            return line;
        },

        canMove : function(x, y) {
            return !this.winner && this.squares[x][y].getPlayer() == null;
        },

        getWinningLine : function () {
            let line = new Line();
            let x = 0;
            let y = 0;

            // check columns
            while (this.winner == null && x < this.sideSize) {
                line.clear();
                for (y = 0; y < this.sideSize; y++) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
                x++;
            }

            // check rows
            y = 0;
            while (this.winner == null && y < this.sideSize) {
                line.clear();
                for (x = 0; x < this.sideSize; x++) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
                y++;
            }

            // check bottom right to top left diagonal
            if (this.winner == null) {
                line.clear();
                for (x = 0, y = 0; x < this.sideSize && y < this.sideSize; x++, y++) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
            }

            // check bottom left to top right diagonal
            if (this.winner == null) {
                line.clear();
                for (x = 0, y = this.sideSize - 1; x < this.sideSize && y >= 0; x++, y--) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
            }

            return line;
        }

};
}}}

Save this code to a file "GameBoard.js"

Class Gameosx:

{{{#!java
/*
 * Code from http://townx.org/blog/elliot/introduction-sorts-javascript-desktop-application-development-gjs-and-clutter
 * Commented and update to clutter 1.10 by Carlos Soriano
 */

/*
 * TODO:
 * - use a layout to put rectangles on the stage, rather than absolute positioning
 * - fix file searchPath so it works when run from anywhere
 */

//X is always the first player
//NB relies on a patched gjs with a 'print' function (used to show the winner)

//import local file - NB this means the script only works from this directory at the moment
imports.searchPath.push('.');
const Ox = imports.GameBoard;
//Import clutter from gi repository (GObjectintrospection)
const Clutter = imports.gi.Clutter;
//This class help you to enclosure the "this"
const Lang = imports.lang;

const OX_PLAYERS = ["X", "O"];
const OX_SQUARE_SIZE_PX = 100;
const OX_FONT_SIZE = OX_SQUARE_SIZE_PX * 0.95;
const OX_LINE_WIDTH_PX = 10;
const OX_SIDE_SIZE = 3;
const OX_TEXT_COLOR = new Clutter.Color( {'red':255, 'blue':255, 'green':255, 'alpha':255} );
const OX_STRIKE_COLOR = new Clutter.Color( {'red':255, 'blue':0, 'green':0, 'alpha':255} );

/**
 * Class to define the view of the board, it means, to define the visual of our
 * program. There is where Clutter have the action
 * 
 * @constructor
 * @param {Integer} players - number of players
 * @param {Integer} sideSize - number of squares to play
 */
function BoardView(players, sideSize) {
    this._init(players, sideSize);
};

BoardView.prototype = {
        _init : function (players, sideSize) {
            this.board = new Ox.Board(players, sideSize);
            /*
             * The board size will be the side size per the size of the square
             * to play plus the lines between squares to separate squares to
             * make the visual more clear
             */
            this.boardSizePx = (sideSize * OX_SQUARE_SIZE_PX) + (OX_LINE_WIDTH_PX * (sideSize + 1));
            // Initialize clutter
            Clutter.init (null);
            // Create new stage for our window and our actors
            this.stage = new Clutter.Stage();
            // We connect the destroy event to quit from the mainloop when we close the
            // window.
            this.stage.connect("destroy", Clutter.main_quit);
            //Set the title
            this.stage.title = "3 en raya";
            // The size of the visual board
            this.stage.set_size(this.boardSizePx, this.boardSizePx);

            let colorOfSquare = new Clutter.Color( {'red':50, 'blue':50, 'green':50, 'alpha':255} );

            /*
             * We create a square actor for each place to play. Also, we connect
             * each square actor to a mouse event for when we click in the
             * square actor to play with this square. This event will cause that
             * the actor will be painted as played, and check at the same time,
             * the actor will check if someone win the game.
             */
            for (let i = 0; i < sideSize; i++)
            {               
                for (let j = 0; j < sideSize; j++)
                {
                    let xpos = ((i + 1) * OX_LINE_WIDTH_PX) + (i * OX_SQUARE_SIZE_PX);
                    let ypos = ((j + 1) * OX_LINE_WIDTH_PX) + (j * OX_SQUARE_SIZE_PX);

                    let squareActor = new Clutter.Actor();
                    squareActor.set_size(OX_SQUARE_SIZE_PX, OX_SQUARE_SIZE_PX);
                    squareActor.set_background_color(colorOfSquare);
                    squareActor.set_position(xpos, ypos);
                    /*
                     * We make the actor reactive, because we want to make the
                     * square interactive and responsible of the mouse events.
                     */                 
                    squareActor.set_reactive(true);

                    let x = i;
                    let y = j;
                    /*
                     * We connect the press event of the mouse to a function.
                     * The function is defined inside. It is called "anonymous
                     * function" because, as you see it hasn't got a name. It is
                     * very useful to define functions quickly that is not
                     * needed outside there.
                     * 
                     * Also you can see that we use Lang.bind(). As you can see
                     * in this tutorial, in Knowing javascript->introducing
                     * javascript, we need this because we will use the "this"
                     * outside of his scope. This is a real example of this. If
                     * you think a little, when a event is happens, the funtion
                     * in the second parameter is called. BUT, we called a
                     * function that inside it uses the "this"...and the "this"
                     * at the moment of the calling is not THIS object, it is
                     * the object that do the callback. So, we need to "close"
                     * the this inside a virtual closure. We acomplish this
                     * using Lang.bind.
                     * 
                     * In summary, we need Lang.bind when we will use the "this"
                     * outside of his scope. A example is in callbacks. All
                     * callbacks that we use with the "this" word inside we will
                     * need the Lang.bind.
                     * 
                     * If you don't know what a callback is, see
                     * http://en.wikipedia.org/wiki/Callback_(computer_programming)
                     * 
                     * Basically is a function as a parameter to another
                     * function.
                     */
                    squareActor.connect('button-press-event',
                            Lang.bind(this, function(actor, event)
                                    {
                                // Make sure that the we didn't play in this
                                // square before
                                if (this.board.canMove(x, y))
                                {
                                    let nextPlayer = this.board.getNextPlayer();

                                    // Get the line if some player won
                                    let line = this.board.makeMove(x, y, nextPlayer);

                                    this.markMove(squareActor, nextPlayer);
                                    // If line returned is a valid win play
                                    if (line.winsFor())
                                    {
                                        this.strikeThrough(line);
                                    }
                                    // If nobody win, swicth player
                                    this.board.switchPlayer();
                                }
                                    }));
                    // We add each square to the stage
                    this.stage.add_actor(squareActor);
                }
            }
        },

        /**
         * Draw the line when some player won.
         * 
         * @param line - The line that we will draw.
         * @see Line
         */
        strikeThrough : function (line)
        {
            let first = line.first();
            let last = line.last();

            let height = 0;
            let width = 0;
            let x = 0;
            let y = 0;
            let rotate = 0;
            let straight_line_length = this.boardSizePx * 0.95;

            if (first.getX() == last.getX())
            {
                // column
                width = OX_LINE_WIDTH_PX  / 2;
                height = straight_line_length;
                x = ((first.getX() + 0.5) * OX_SQUARE_SIZE_PX) + ((first.getX() + 0.75) * OX_LINE_WIDTH_PX);
                y = (this.boardSizePx - straight_line_length) / 2;
            }
            else if (first.getY() == last.getY())
            {
                // row
                width = straight_line_length;
                height = OX_LINE_WIDTH_PX / 2;
                x = (this.boardSizePx - straight_line_length) / 2;
                y = ((first.getY() + 0.5) * OX_SQUARE_SIZE_PX) + ((first.getY() + 0.75) * OX_LINE_WIDTH_PX);
            }
            else
            {
                // diagonal, length calculated aplying Pitagoras theorem
                width = Math.sqrt(straight_line_length * straight_line_length * 2);
                height = OX_LINE_WIDTH_PX / 2;
                x = (this.boardSizePx - width) / 2;
                y = (this.boardSizePx / 2) - (height / 2);

                if (first.getX() == first.getY()) {
                    rotate = 45;
                }
                else {
                    rotate = -45;
                }
            }
            // Create a new rectangle to draw a line
            let strike = new Clutter.Actor ();
            strike.set_background_color (OX_STRIKE_COLOR);
            strike.set_position (x, y);
            strike.set_size (width, height);

            /*
             * If the line is in diagonal, we have to rotate the actor. To
             * rotate it we have to indicate the axis to rotate and the center
             * of the rotation. The axis will be z (trougth the screen), and the
             * center of rotation will be the center of the square actor. The
             * last 0 is the depth, that as you can imagine, it haven't got
             * depth.
             * http://docs.clutter-project.org/docs/clutter/stable/ClutterActor.html#clutter-actor-set-rotation
             */
            if (rotate != 0) {
                strike.set_rotation (Clutter.RotateAxis.Z_AXIS, rotate, width / 2, height / 2, 0);
            }
            // add the line actor to the stage to sow it
            this.stage.add_actor(strike);
        },
        /**
         * This function allow you to show a move from one player. The function
         * will draw a "X" or a "O" depending
         */
        markMove : function(clickedSquare, player)
        {
            //Put the letter associated with this player("X" or "O") in a text actor of clutter
            let letterToDraw = new Clutter.Text( {"text":player, "color":OX_TEXT_COLOR} );
            //Set the font, and size of the text
            letterToDraw.set_font_name("Sans Bold " + OX_FONT_SIZE + "px");
            //Get the position of the rectangle
            let [r_x, r_y] = clickedSquare.get_position();
            let offset_x = (clickedSquare.get_width() / 2) - (letterToDraw.get_width() / 2); 
            let offset_y = (clickedSquare.get_height() / 2) - (letterToDraw.get_height() / 2);

            letterToDraw.set_position(r_x + offset_x, r_y + offset_y);
            letterToDraw.move_anchor_point_from_gravity (Clutter.Gravity.CENTER);

            this.stage.add_actor(letterToDraw);
            /*
             * WARNING: The next code is deprecated. Instead of this we have to use a simple
             * code. The code of the new version will be:
             *  actorRectangle.animate(Clutter.AnimationMode.EASE_OUT_ELASTIC, 500,
             * "scale-x", 0.5, "scale-y", 0.5, NULL);
             */

            /*
             * Create a new timeline as we see in the animation headland(its function it's like the time bar of youtube
             *  videos) with duration 500ms
             */
            let timeline = new Clutter.Timeline( {'duration':500} );
            /*
             * Create a new function to control the timeline and the properties of the actor.
             * This will use the ease out elastic type of animation, resulting in a animation that cause the letter
             * seems an elastic thing
             */
            let alpha = new Clutter.Alpha ( {'timeline':timeline, 'mode':Clutter.AnimationMode.EASE_OUT_ELASTIC} );
            //Create a new behaviour to the actor. We want that the actor scale to 0.5 of its size.
            let behaviour = new Clutter.BehaviourScale( {'alpha':alpha, 'x_scale_start':1.0, 'y_scale_start':1.0, 
                'x_scale_end':0.5, 'y_scale_end':0.5} );
            //Apply the behaviour to the letter actor
            behaviour.apply (letterToDraw);
            //Start the animation
            timeline.start ();
        },

        show : function()
        {
            //Show the stage and his actors
            this.stage.show();
            //Start our program with the GUI we created
            Clutter.main();
        }
};

//Create our GUI
let view = new BoardView(OX_PLAYERS, OX_SIDE_SIZE);
//Start our GUI
view.show();
}}}

Save this code to a file "Gameosx.js" and to execute the entire game we enter in a terminal:
{{{
gjs-console Gameosx.js
}}}

Tachan! You create a simple game with clutter and javascript. Enjoy!

<<Anchor(knowingClutter-problems)>>
=== Problems ===

''I haven't got Gjs in my software management!''

Install from source:
 * https://live.gnome.org/Gjs
 * https://live.gnome.org/GObjectIntrospection
 * http://www.clutter-project.org/download

[[#index | Go to index]]

<<Anchor(allCode)>>
== All code to download or modify ==
If you want all the code posted in this wiki, you can donwload using git from here

https://github.com/seiryu89/StepByStepTutorial

Also, if you want to modify something, fix something or add some code to the wiki, I appreciated you if you use the git repository above and change the wiki after. If we do this in this manner we can have a repository with all the code to download and everything update.
