= Step by step tutorial to create extensions =

NOT COMPLETED AND REVISED YET!

''Phrases or words in bigger need to be reviewed to ensure that are correct''

''To review''

[[#toReview-4]]
[[#toReview-5]]
[[#toReview-6]]
[[#toReview-7]]

This tutorial is for gnome 3.4. The main differences between 3.4 and 3.6 are:


 * !OpenSearch and !PlacesDisplay were removed
 * The !ViewSelector tab system was replaced with a simpler page API
 * The screensaver is in process and accessed as Main.screenShield
 * The session mode now changes at runtime (and this affect enablement of extensions)
 * Some modules were moved into js/ui/components/
 * St.!IconType was removed, so you need to add ‘-symbolic’ to icon names
 * Notifications, status items and search providers deal with GIcons, not icon names
 * Message tray sources can override the right click menu
 * ConsoleKit/Systemd were unified as util.!LoginManager
 * Input sources are stored in GSettings and affect IBus too
 * The volume status indicator was split in the menu and the actual indicator

So take them into account until I update this wiki to gnome 3.6


= Index =

<<Anchor(index)>>
 * [[#fromScratch | From scratch]]
   * [[#fromScratch-settingUpEclipse | Setting up eclipse]]
   * [[#fromScratch-settingUpEclipse-problems | Problems setting up eclipse]]
   * [[#fromScratch-usingEclipse|Using eclipse]]
 * [[#knowingJavascript | Knowing javascript for gnome shell]]
   * [[#knowingJavascript-introducingJavascript | Introducing javascript]]
   * [[#knowingJavascript-howExtends|How extends functionality]]
 * [[#knowingClutter|Knowing clutter]]
   * [[#knowingClutter-introducingClutter|Introducing clutter]]
   * [[#knowingClutter-events | Events]]
   * [[#knowingClutter-someExamples|Some examples with raw clutter]]
     *[[#knowingClutter-someExamples-init | Init clutter and stage]]
     *[[#knowingClutter-someExamples-draw | Draw something]]
     *[[#knowingClutter-someExamples-signals | Add some signals to make it interactive]]
     *[[#knowingClutter-someExamples-animate | Animations]]
     *[[#knowingClutter-someExamples-game | Game with all together]]
   * [[#knowingClutter-problems | Problems]]
 * [[#knowingGnomeShell|Knowing gnome shell]]
   * [[#knowingGnomeShell-introducing|Introducing gnome shell]]
   * [[#knowingGnomeShell-interactionWithClutter|Interaction with clutter]]
   * [[#knowingJavascript-Gjs|Gjs and how to use c API gnome libraries from javascript]]
   * [[#knowingGnomeShell-API|API]]
 * [[#lookingGlass|Looking glass]]
 * [[#myFirstExtension | My first extension]]
 * [[#errorsAndDebug | How to know your errors and debug your code]]
   * [[#errorsAndDebug-knowYourErrors|Know your errors]]
   * [[#errorsAndDebug-redirectOutput|Redirect output to error console]]
 * [[#interestingClasses | Accessing some interesting objects of gnome shell]]
 * [[#extensionExamples | Some extensions examples]]
   * [[#extensionExamples-extensionUsingDash|Extension using dash]]
   * [[#extensionExamples-extensionUsingUIElements|Extension using UI elements]]
   * [[#extensionExamples-multipleFileExtension|Multiple file extension]]
   * [[#extensionExamples-extensionUsingDBUS|Extension using DBUS to comunicate between apps]]
 * [[#allCode | All code to download or modify]]
 * [[#support | Support]]

<<Anchor(fromScratch)>>
= From scratch =
<<Anchor(fromScratch-settingUpEclipse)>>
== Setting up eclipse ==
<<Anchor(fromScratch-settingUpEclipse-whyUseAnIde)>>
=== Why use an IDE ===

It is very helpful to develop using an IDE with javascript support. It will help us with code folding, autocompletion, outline, etc.

Gnome has his own IDE for develop, called Anjuta. The problem is that IDE has some lacks, like autocompletion, code folding, etc... so for me it is better to develop using eclipse until anjuta gets to have this kind of features.

So, we start setting up eclipse to have javascript support.

Setting up eclipse

Install eclipse from your app store of your distribution. Open eclipse and select your workspace. Go to Help. Install new software. Select Work with "All available sites". Search for javascript. Install. That's it!
<<Anchor(fromScratch-settingUpEclipse-problems)>>
=== Problems ===

''I haven't got eclipse in my distribution''

Go to http://www.eclipse.org/downloads/ and download eclipse classic.
I select work with "All available sites" but nothing is shown.
Go to "Find more software by working with "All available software sites" preferences" and add your eclipse download site which depens on the eclipse version you have. For eclipse Juno it is http://download.eclipse.org/releases/juno.

[[#index | Go to index]]

<<Anchor(fromScratch-usingEclipse)>>
== Using eclipse ==

When you create an extension, the extension is saved at ~/.local/shared/gnome-shell/extensions with a gnome-shell extension folder format, so you can't create a project here and edit the files expecting that each change you do reflects directly in the gnome-shell. So, if we use eclipse to develop extensions, the best way is to open directly the file you are editing, like ~/.local/shared/gnome-shell/extensions/myExtensionFolder/myExtension.js

To visualize the changes, you need to have enabled the extension. To enable the extension use gnome-tweak-tool.

After that, every time you make a change, you will have to save the file and restart the shell (Alt+F2 , write "r" without quotes, enter).

[[#index | Go to index]]

<<Anchor(knowingJavascript)>>
= Knowing javascript for gnome shell =

<<Anchor(knowingJavascript-introducingJavascript)>>
== Introducing javascript ==
JavaScript (sometimes abbreviated JS), which is a prototype-based scripting language, is dynamic, weakly typed and has first-class functions. It is a multi-paradigm language, supporting object-oriented, imperative, and functional programming styles.

Gnome-shell is written in javascript because it allows a quick prototyping. It means that it allows to change the code quickly, and do a lot of changes in a easy way. It is needed because gnome-shell is an application that is in a quick development, and it changes a lot in short time.
<<Anchor(toReview-1)>>
The difference between javascript and other dynamic languages (python, ruby, php, etc...) is that javascript doesn't depend of a specific platform, so gnome-shell can run it with its own platform under it (Gjs).

This is an extended web page about programming in javascript (web oriented). Some things changes because we are not programming for the web, but most is the same. There's the web:
https://developer.mozilla.org/en-US/learn/javascript

Quick characteristic things:
 * Classes, objects, variables, functions is less or more the same.
 * To access some function or variable: object.function() / object.variable or object.function() / object['function']()
 * You can modify the code while running. It is called monkey-patching.
 * class.prototype allow you inheritance or modify the base class directly rewriting his code.
 * Variables without scope. So, if you do "var x", x will be in all of your program. The only way to restrict the scope is "let x" what makes the variable x only usable in his scope.
 * If we want to use "this" outside of his scope we need the class Lang. The use is in this way: functionOutsideOfScope(Lang.bind(this, this.function())). See https://live.gnome.org/GnomeShell/Gjs_StyleGuide ""this" in closures" to see one example.

[[#index | Go to index]]

<<Anchor(knowingJavascript-howExtends)>>
== How extends functionality ==

'' Don't do anything until we arrive to the extensions headland, because you don't know how to create, enable, as well as some important parts of an extension''

The main way to extend functionality is rewritten the code of the gnome shell in this way:

We have a class called Workspace (File: /usr/share/gnome-shell/js/ui/Workspace. The class is something like this:
{{{#!java
const Workspace = new Lang.Class({
    Name: 'Workspace',

    _init : function(metaWorkspace, monitorIndex) {
        // When dragging a window, we use this slot for reserve space.
        this._reservedSlot = null;
        this.metaWorkspace = metaWorkspace;
etc...

_lookupIndex: function (metaWindow) {
        for (let i = 0; i < this._windows.length; i++) {
            if (this._windows[i].metaWindow == metaWindow) {
                return i;
            }
        }
        return -1;
    },
})
}}}

And we want to modify the _lookupIndex to return always 1. So we do this in our extension:

{{{#!java
Workspace.prototype['_lookupIndex'] = function (metaWindow){ return 1; }
}}}

As we saw in the javascript tutorial, we can modify the base class editting his "prototype". To access some function, object, variable, etc. we put the name of the function/variable/object/etc bracketed in a string format. In the right side of equal, we write our function that we want to replace the function of the left side.

After enabling our extension and restarting the shell, if we execute the Workspace._lookupIndex function, we get always 1 in return value.

Another way to extend funcionality is to injecting code, with this function:
{{{#!java
function injectToFunction(parent, name, func)
{
	let origin = parent[name];
	parent[name] = function()
	{
		let ret;
		ret = origin.apply(this, arguments);
		if (ret === undefined)
			ret = func.apply(this, arguments);
		return ret;
	}
	return origin;
}

function removeInjection(object, injection, name)
{
	if (injection[name] === undefined)
		delete object[name];
	else
		object[name] = injection[name];
}

}}}

And to inject some code in a function use this in this way:

{{{#!java
//We store the injection, for after have the option to dissable the injection.
inections=[];
injections['injectionOfLookupIndex']=injectToFunction(Workspace.prototype, '_lookupIndex',  function(){return 1;});
}}}

And to desinject the code:

{{{#!java
removeInjection(Workspace.prototype, injections,  'injectionOfLookupIndex');
}}}

<<Anchor(toReview-4)>>
With this, we can add some code to the function without rewriting all the function. Our code is written '''~+ before the return statement of the original function and after all code of original function+~'''

We'll see why we need to desinject the code in "my first extensions" headland.

[[#index | Go to index]]

<<Anchor(knowingClutter)>>
= Knowing clutter =

<<Anchor(knowingClutter-introducingClutter)>>
== Introducing clutter ==

Clutter is a C programming API that allows you to create simple but visually appealing and involving user interfaces. It offers a variety of objects (actors) which can be placed on a canvas (stage) and manipulated by the application or the user. It is therefore a "retained mode" graphics API. Unlike traditional 2D canvas APIs, Clutter allows these actors to move partly in the Z dimension.
It is used by gnome-shell to implement all the GUI of gnome-shell.

There's three technologies that allow us to use easily clutter with javascript:

<<Anchor(toReview-5)>>
Clutter use [[https://live.gnome.org/GObjectIntrospection | GObjectIntrospection]], project that allows to use c programs from other programming languages directly and it allows us to work in javascript with it, instead of using c. '''~+It works transforming the c program API in general files(xml or custom files) allowing to write easily a binding in other program language that can interpret it.+~'''

From that, we need a program that gets the general file result from GObjectIntrospection and transform it to a specific program language, like javascript. This program is specific for each program language, and for javascript it is called [[https://live.gnome.org/Gjs | Gjs]].

Also, gnome-shell has his own clutter-based toolkit, called [[http://developer.gnome.org/st/stable/ | St]], that gives you some useful actors (components in the GUI). Also St is the way for gnome-shell to interact with CSS theming; so the form
and color of every button, dialog etc. of gnome shell is defined in /usr/share/gnome-shell/theme, and the only class that
manage this css is St.


So we have:
Clutter in c -> GObjectIntrospection(result in a generl file) ->
 * -> Gjs (interprets general file from GObjectIntrospection to javascript)
 * -> pyclutter (interprets general file from GObjectIntrospection to python)
 * -> clutter-perl (interprets general file from GObjectIntrospection to perl)
 * -> etc.

All bindings: http://www.clutter-project.org/about/language-bindings

Important characteristic things in clutter are:
 * Stage: contain some actors (text, rectangles etc). It's the window of the application. Also is an actor.
 * Actor: GUI object.
   * show() : you have to show each actor to be visible to the user.
   * hide() : hide the actor.

[[#index | Go to index]]

<<Anchor(knowingClutter-events)>>
== Events ==

We need events to do the GUI interactive and reactive to mouse clicks and keyboard inputs.
Also, we can use custom events inside our program, to communicate through events, functions in our program.

By default, each actor in clutter has these events:
 * button-press-event: Emitted when the user presses the mouse over the actor.
 * button-release-event: Emitted when the user releases the mouse over the actor.
 * motion-event: Emitted when the user moves the mouse over the actor.
 * enter-event: Emitted when the user moves the mouse in to the actor's area.
 * leave-event: Emitted when the user moves the mouse out of the actor's area.
All events:
http://docs.clutter-project.org/docs/clutter/stable/ClutterActor.html
And look at the bottom, here are all the events emitted by the actor.
 
We can associate each event with one actor and a function that will be called when the event occurs, and will carry out what we want to happen when the event occurs (like move the actor when we click it, change his opacity when we hover it, etc.). This association is called "connect".

So, to connect one actor to one event:
actor.connect(eventName, functionToCallWhenEventOccurs);

For example:
{{{#!java
//Create new actor
actor=new Clutter.Actor();
/*
 * Connect the actor to the enter-event and it will call moveActor function when
 * we click the actor
*/
actor.connect('enter-event', moveActor);

/*
 * Automatically, the enter event pass some parameters to the function.
 * these parameters are the event and the actor.
 * http://docs.clutter-project.org/docs/clutter/stable/ClutterActor.html
 * in the document above, search for "The "leave-event" signal"
*/
function  moveActor(actor, event)
{
    let x=0;
    let y=2;
    //Set the new position to the actor.
    actor.set_position(x, y);
}
}}}

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples)>>
== Some examples with raw clutter ==

Now we will see some examples with clutter, but gnome shell is not there, only clutter.
Also, if you want all the code, you can get it from github. See [[#allCode | all the code]].

<<Anchor(knowingClutter-someExamples-init)>>
=== Initiate clutter and stage ===
{{{#!java
//Import the clutter class form the gi repository(the object introspection repository)
const Clutter = imports.gi.Clutter;
// Initialize clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object so many of that
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the mainloop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some title
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 150,
    blue : 0,
    green : 0,
    alpha : 255
}));
// As we say, the stage is also an actor, so we shoe it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();
}}}

Save this code to a file "InitClutterAndStage.js" and to execute it we enter in a terminal:
{{{
gjs-console InitClutterAndStage.js
}}}
As you see, we are using gjs to execute the file, so you have to have Gjs installed
(search for Gjs in your software management application).

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples-draw)>>
=== Draw something ===

Now we try to draw a rectangle in the stage:
{{{#!java
//Import the clutter class from the gi repository (the object introspection repository).
const Clutter = imports.gi.Clutter;
// Initialize clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object so many of that
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the main loop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some tittle
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 10,
    blue : 10,
    green : 10,
    alpha : 255
}));

// Create a new actor
let actorRectangle = new Clutter.Actor();
// Make it like a rectangle
actorRectangle.set_size(100, 100);
actorRectangle.set_position(100, 100);
/*
 * Colors are made in RGBA http://en.wikipedia.org/wiki/RGBA_color_space
 * Basically, Red, Green, Blue, Alpha(transparency). Each factor, between 0-255
 */
actorRectangle.set_background_color(new Clutter.Color({
    red : 100,
    blue : 100,
    green : 100,
    alpha : 255
}));

stage.add_actor(actorRectangle);
// As we say, the stage is also an actor, so we show it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();
}}}

Save this code to a file "DrawSomething.js" and to execute we enter in a terminal:
{{{
gjs-console DrawSomething.js
}}}

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples-signals)>>
=== Add some signals to make it interactive ===

Now, we do something funny. We will add a hover event to the rectangle actor, and each time
we hover the actor, the actor will change the position randomly.

{{{#!java
//Import the clutter class from the gi repository(the object introspection repository)
const Clutter = imports.gi.Clutter;

// Initialize clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object so many of that
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the main loop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some tittle
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 10,
    blue : 10,
    green : 10,
    alpha : 255
}));

// Create a new actor
let
actorRectangle = new Clutter.Actor();
// Put his x, y size, position and background color
actorRectangle.set_size(100, 100);
actorRectangle.set_position(100, 100);
actorRectangle.set_background_color(new Clutter.Color({
    red : 100,
    blue : 100,
    green : 100,
    alpha : 255
}));

// Sets actor as reactive. Reactive actors will receive events.
actorRectangle.set_reactive(true);
/*
 * Connect the actor to a event. When you hover it, function in the second
 * parameter will be called. So we are passing a reference to a function.
 */
actorRectangle.connect('enter-event', changeRectanglePosition);

stage.add_actor(actorRectangle);
// As we say, the stage is also an actor, so we show it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();

function changeRectanglePosition()
{
    // We get the size of the stage (our window)
    let [sizex, sizey] = stage.get_size();
    /*
     * Math.random returns a float between 0 and 1, so we multiply by the size of
     * the stage and we acomplish a number between 0-sizeStage
     */
    let newx = Math.floor(Math.random() * sizex);
    let newy = Math.floor(Math.random() * sizey);
    /*
     * We can access to that because it is a global variable. Also, remember that
     * with "let" the scope is the block and with "var" the scope is all the
     * environment. In this case,the block is all the environment We put the new
     * random position
     */
    actorRectangle.set_position(newx, newy);
}
}}}

Save this code to a file "!ClutterEvents.js" and to execute we enter in a terminal:
{{{
gjs-console ClutterEvents.js
}}}

[[#index | Go to index]]

<<Anchor(knowingClutter-someExamples-animate)>>
=== Animations ===

Now, we add an animation to the actor. This animation only will start if we hover the actor. So we have to put the animation inside the function
we call when hover the actor.

{{{#!java
//Import the clutter class from the gi repository(the object introspection repository)
const
Clutter = imports.gi.Clutter;

// Initialice clutter
Clutter.init(null);
/*
 * Create a stage. This function returns a new default stage, with its own
 * window. ClutterStage is derived from the ClutterActor object, so many of these
 * object's functions are useful for the stage. For instance, call
 * Clutter.Stage.get_default().show() to make the stage visible.
 */
let stage = new Clutter.Stage();

// We connect the destroy event to quit from the mainloop when we close the
// window.
stage.connect("destroy", Clutter.main_quit);
// Put some title
stage.title = "Test";
// Set a color to the stage to show that it is working
stage.set_background_color(new Clutter.Color({
    red : 10,
    blue : 10,
    green : 10,
    alpha : 255
}));

// Create a new actor
let actorRectangle = new Clutter.Actor();
// Put his x, y size, position and background color
actorRectangle.set_size(100, 100);
actorRectangle.set_position(100, 100);
actorRectangle.set_background_color(new Clutter.Color({
    red : 100,
    blue : 100,
    green : 100,
    alpha : 255
}));

// Sets actor as reactive. Reactive actors will receive events.
actorRectangle.set_reactive(true);
/*
 * Connect the actor to a event. When you hover it, function in the second
 * parameter will be called. So we are passing a reference to a function.
 */
actorRectangle.connect('enter-event', changeRectanglePosition);
// Add the rectangle to the stage
stage.add_actor(actorRectangle);

// As we say, the stage is also an actor, so we show it to make visible
stage.show();
// Start a main loop so that the stage can animate its contents and respond to
// user interaction.
Clutter.main();

function changeRectanglePosition()
{
    // We get the size of the stage(our window)
    let [sizex, sizey] = stage.get_size();
    /*
     * Math.random return a float between 0 and 1, so we multiply by the size of
     * the stage and we acomplish a number between 0-sizeStage
     */
    let newx = Math.floor(Math.random() * sizex);
    let newy = Math.floor(Math.random() * sizey);
    /*
     * We can access to that because is a global variable. Also, remember that
     * with "let" the scope is the block and with "var" the scope is all the
     * environment. In this case,the block is all the environment We put the new
     * random position
     */
    actorRectangle.set_position(newx, newy);

    /*
     * WARNING: The next code is deprectaed since clutter 1.6, but we don't have
     * even the easy way to animate actors in raw clutter in stable version of
     * fedora 17, so we use deprecated code. The easy way in new code is:
     * actorRectangle.animate(Clutter.AnimationMode.EASE_OUT_ELASTIC, 500,
     * "scale-x", 0.5, "scale-y", 0.5, NULL); New code to animate actors:
     * http://docs.clutter-project.org/docs/clutter/stable/clutter-Implicit-Animations.html
     */

    /*
     * To animate an actor we need three things timeline: think about it like
     * play, pause and stop and bar time of your videos alpha: how is made the
     * transition, because we can made a tansition bounding, quickly at first
     * and later slowly, etc. There are all the transitions:
     * http://docs.clutter-project.org/docs/clutter/stable/clutter-Implicit-Animations.html#ClutterAnimationMode
     * behaviour: what property of the actor we want to animate, scale, opacity,
     * etc. each property has his own class, behaviourScale, behaviourOpacity,
     * etc. all properties of behaviourScale:
     * http://docs.clutter-project.org/docs/clutter/stable/ClutterBehaviourScale.html
     */
    let timeline = new Clutter.Timeline({
        'duration' : 500
    });
    let alpha = new Clutter.Alpha({
        'timeline' : timeline,
        'mode' : Clutter.AnimationMode.EASE_OUT_ELASTIC
    });
    let behaviourScale = new Clutter.BehaviourScale({
        'alpha' : alpha,
        'x_scale_start' : 1.0,
        'y_scale_start' : 1.0,
        'x_scale_end' : 0.5,
        'y_scale_end' : 0.5
    });
    behaviourScale.apply(actorRectangle);
    timeline.start();
}
}}}

Save this code to a file "ClutterAnimations.js" and to execute we enter in a terminal:
{{{
gjs-console ClutterAnimations.js
}}}

<<Anchor(knowingClutter-someExamples-game)>>
=== Game with all together ===

Now we will do something funny, a (in Spanish, it is called "3 en raya") game.
In this game we will have objects painted, events and animations.
We need a board, two players, and two types of tokens.
It suposed that you already has read the previous headlands about clutter.

We need two classes, !GameBoard, that define the program behaviour and data and Gameosx that define the GUI with clutter.

The code is documented with [[http://www.naturaldocs.org | Natural docs]]. You can document the code and generate a html documentation, that it is very helpful. Also, remember that document the code is very important, and if you can do
a html documentation, it is very useful.

Class !GameBoard:

{{{#!java
/*
    Code from http://townx.org/blog/elliot/introduction-sorts-javascript-desktop-application-development-gjs-and-clutter
    Commented and update to clutter 1.10 by Carlos Soriano
 */

/*
    Define what is a square in the game
    We use this way to define a class,
    using the prototype.
    Visit <Ways to define a "class" in JS at http://www.phpied.com/3-ways-to-define-a-javascript-class>
 */

/*
  Class: Square

  Define a square to play in the board This "class" use the method
  prototype to do define a "class" in javascript

  Parameters:
       x - position x of the square. For normal use, 0 to 2
       y - position y of the square. for normal use, 0 to 2
 */
function Square(x, y, player) {
    this.player = player;
    this.x = x;
    this.y = y;
};

Square.prototype = {
        getPlayer : function () {
            return this.player;
        },

        setPlayer : function (player) {
            this.player = player;
        },

        getX : function () {
            return this.x;
        },

        getY : function () {
            return this.y;
        }
};


/*
  Class: Line

       Class to define the line drawn when some player won
 */
function Line () {
    this.squares = [];
};

Line.prototype = {
        first : function () {
            return this.squares[0];
        },

        last : function () {
            return this.squares[this.squares.length - 1];
        },

        addSquare : function (square) {
            this.squares.push(square);
        },

        winsFor : function () {
            let current = null;
            let last = null;

            for (let i = 0; i < this.squares.length; i++) {
                current = this.squares[i].getPlayer();
                if (i > 0 && current != last) {
                    last = null;
                    break;
                }
                else {
                    last = current;
                }
            }
            return last;
        },

        clear : function () {
            this.squares = [];
        }
};

/*
  Class: Board

        Define the board of the game

  Parameters:

        players - The count of the players
        sideSize - The quantity of squares can have the board in a side
 */

function Board(players, sideSize) {
    this._init(players, sideSize);
};

Board.prototype = {

        _init : function(players, sideSize) {
            this.squares = [];
            this.sideSize = sideSize;
            this.winner = null;
            this.playerPos = 0;
            this.players = players;

            for (var i = 0; i < sideSize; i++) {
                this.squares[i] = [];
                for (var j = 0; j < sideSize; j++) {
                    this.squares[i][j] = new Square(i, j, null);
                }
            }
        },

        switchPlayer : function() {
            this.playerPos = this.playerPos + 1;
            if (this.playerPos >= this.players.length) {
                this.playerPos = 0;
            }
        },

        getNextPlayer : function() {
            return this.players[this.playerPos];
        },

        makeMove : function(x, y, player) {
            this.squares[x][y].setPlayer(player);
            let line = this.getWinningLine();
            return line;
        },

        canMove : function(x, y) {
            return !this.winner && this.squares[x][y].getPlayer() == null;
        },

        getWinningLine : function () {
            let line = new Line();
            let x = 0;
            let y = 0;

            // check columns
            while (this.winner == null && x < this.sideSize) {
                line.clear();
                for (y = 0; y < this.sideSize; y++) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
                x++;
            }

            // check rows
            y = 0;
            while (this.winner == null && y < this.sideSize) {
                line.clear();
                for (x = 0; x < this.sideSize; x++) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
                y++;
            }

            // check bottom right to top left diagonal
            if (this.winner == null) {
                line.clear();
                for (x = 0, y = 0; x < this.sideSize && y < this.sideSize; x++, y++) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
            }

            // check bottom left to top right diagonal
            if (this.winner == null) {
                line.clear();
                for (x = 0, y = this.sideSize - 1; x < this.sideSize && y >= 0; x++, y--) {
                    line.addSquare(this.squares[x][y]);
                }
                this.winner = line.winsFor();
            }

            return line;
        }

};
}}}

Save this code to a file "!GameBoard.js"

Class Gameosx:

{{{#!java
/*
 * Code from http://townx.org/blog/elliot/introduction-sorts-javascript-desktop-application-development-gjs-and-clutter
 * Commented and update to clutter 1.10 by Carlos Soriano
 */

/*
 * TODO:
 * - use a layout to put rectangles on the stage, rather than absolute positioning
 * - fix file searchPath so it works when run from anywhere
 */

//X is always the first player
//NB relies on a patched gjs with a 'print' function (used to show the winner)

//import local file - NB this means the script only works from this directory at the moment
imports.searchPath.push('.');
const Ox = imports.GameBoard;
//Import clutter from gi repository (GObjectintrospection)
const Clutter = imports.gi.Clutter;
//This class help you to enclosure the "this"
const Lang = imports.lang;

const OX_PLAYERS = ["X", "O"];
const OX_SQUARE_SIZE_PX = 100;
const OX_FONT_SIZE = OX_SQUARE_SIZE_PX * 0.95;
const OX_LINE_WIDTH_PX = 10;
const OX_SIDE_SIZE = 3;
const OX_TEXT_COLOR = new Clutter.Color( {'red':255, 'blue':255, 'green':255, 'alpha':255} );
const OX_STRIKE_COLOR = new Clutter.Color( {'red':255, 'blue':0, 'green':0, 'alpha':255} );

/*
    Class: BoardView

        Class to define the view of the board, it means, to define the visual of our
        program. There is where Clutter have the action

    Parameters:

        players - number of players
        sideSize - number of squares to play
 */
function BoardView(players, sideSize) {
    this._init(players, sideSize);
};

BoardView.prototype = {
        _init : function (players, sideSize) {
            this.board = new Ox.Board(players, sideSize);
            /*
             The board size will be the side size per the size of the square
             to play plus the lines between squares to separate squares to
             make the visual more clear
             */
            this.boardSizePx = (sideSize * OX_SQUARE_SIZE_PX) + (OX_LINE_WIDTH_PX * (sideSize + 1));
            // Initialize clutter
            Clutter.init (null);
            // Create new stage for our window and our actors
            this.stage = new Clutter.Stage();
            // We connect the destroy event to quit from the mainloop when we close the
            // window.
            this.stage.connect("destroy", Clutter.main_quit);
            //Set the title
            this.stage.title = "3 en raya";
            // The size of the visual board
            this.stage.set_size(this.boardSizePx, this.boardSizePx);

            let colorOfSquare = new Clutter.Color( {'red':50, 'blue':50, 'green':50, 'alpha':255} );

            /*
             We create a square actor for each place to play. Also, we connect
             each square actor to a mouse event for when we click in the
             square actor to play with this square. This event will cause that
             the actor will be painted as played, and check at the same time,
             the actor will check if someone win the game.
             */
            for (let i = 0; i < sideSize; i++)
            {			    
                for (let j = 0; j < sideSize; j++)
                {
                    let xpos = ((i + 1) * OX_LINE_WIDTH_PX) + (i * OX_SQUARE_SIZE_PX);
                    let ypos = ((j + 1) * OX_LINE_WIDTH_PX) + (j * OX_SQUARE_SIZE_PX);

                    let squareActor = new Clutter.Actor();
                    squareActor.set_size(OX_SQUARE_SIZE_PX, OX_SQUARE_SIZE_PX);
                    squareActor.set_background_color(colorOfSquare);
                    squareActor.set_position(xpos, ypos);
                    /*
                     We make the actor reactive, because we want to make the
                     square interactive and responsible of the mouse events.
                     */					
                    squareActor.set_reactive(true);

                    let x = i;
                    let y = j;
                    /*
                     We connect the press event of the mouse to a function.
                     The function is defined inside. It is called "anonymous
                     function" because, as you see it hasn't got a name. It is
                     very useful to define functions quickly that is not
                     needed outside there.

                     Also you can see that we use Lang.bind(). As you can see
                     in this tutorial, in Knowing javascript->introducing
                     javascript, we need this because we will use the "this"
                     outside of his scope. This is a real example of this. If
                     you think a little, when a event is happens, the funtion
                     in the second parameter is called. BUT, we called a
                     function that inside it uses the "this"...and the "this"
                     at the moment of the calling is not THIS object, it is
                     the object that do the callback. So, we need to "close"
                     the this inside a virtual closure. We acomplish this
                     using Lang.bind.

                     In summary, we need Lang.bind when we will use the "this"
                     outside of his scope. A example is in callbacks. All
                     callbacks that we use with the "this" word inside we will
                     need the Lang.bind.

                     If you don't know what a callback is, see
                     http://en.wikipedia.org/wiki/Callback_(computer_programming)

                     Basically is a function as a parameter to another
                     function.
                     */ 
                    squareActor.connect('button-press-event',
                            Lang.bind(this, function(actor, event)
                                    {
                                // Make sure that the we didn't play in this
                                // square before
                                if (this.board.canMove(x, y))
                                {
                                    let nextPlayer = this.board.getNextPlayer();

                                    // Get the line if some player won
                                    let line = this.board.makeMove(x, y, nextPlayer);

                                    this.markMove(squareActor, nextPlayer);
                                    // If line returned is a valid win play
                                    if (line.winsFor())
                                    {
                                        this.strikeThrough(line);
                                    }
                                    // If nobody win, swicth player
                                    this.board.switchPlayer();
                                }
                                    }));
                    // We add each square to the stage
                    this.stage.add_actor(squareActor);
                }
            }
        },

        /*
             Function:
             
                 Draw the line when some player won.
                 
             Parameters:
             
                 line - The line that we will draw.
                 
             See Also:
             
                 <Line>
         */
        strikeThrough : function (line)
        {
            let first = line.first();
            let last = line.last();

            let height = 0;
            let width = 0;
            let x = 0;
            let y = 0;
            let rotate = 0;
            let straight_line_length = this.boardSizePx * 0.95;

            if (first.getX() == last.getX())
            {
                // column
                width = OX_LINE_WIDTH_PX  / 2;
                height = straight_line_length;
                x = ((first.getX() + 0.5) * OX_SQUARE_SIZE_PX) + ((first.getX() + 0.75) * OX_LINE_WIDTH_PX);
                y = (this.boardSizePx - straight_line_length) / 2;
            }
            else if (first.getY() == last.getY())
            {
                // row
                width = straight_line_length;
                height = OX_LINE_WIDTH_PX / 2;
                x = (this.boardSizePx - straight_line_length) / 2;
                y = ((first.getY() + 0.5) * OX_SQUARE_SIZE_PX) + ((first.getY() + 0.75) * OX_LINE_WIDTH_PX);
            }
            else
            {
                // diagonal, length calculated aplying Pitagoras theorem
                width = Math.sqrt(straight_line_length * straight_line_length * 2);
                height = OX_LINE_WIDTH_PX / 2;
                x = (this.boardSizePx - width) / 2;
                y = (this.boardSizePx / 2) - (height / 2);

                if (first.getX() == first.getY()) {
                    rotate = 45;
                }
                else {
                    rotate = -45;
                }
            }
            // Create a new rectangle to draw a line
            let strike = new Clutter.Actor ();
            strike.set_background_color (OX_STRIKE_COLOR);
            strike.set_position (x, y);
            strike.set_size (width, height);

            /*
             If the line is in diagonal, we have to rotate the actor. To
             rotate it we have to indicate the axis to rotate and the center
             of the rotation. The axis will be z (trougth the screen), and the
             center of rotation will be the center of the square actor. The
             last 0 is the depth, that as you can imagine, it haven't got
             depth.
             http://docs.clutter-project.org/docs/clutter/stable/ClutterActor.html#clutter-actor-set-rotation
             */
            if (rotate != 0) {
                strike.set_rotation (Clutter.RotateAxis.Z_AXIS, rotate, width / 2, height / 2, 0);
            }
            // add the line actor to the stage to sow it
            this.stage.add_actor(strike);
        },
        /*
            Function: markMove

                This function allow you to show a move from one player. The function
                will draw a "X" or a "O" depending of the player.

            Parameters:
                clickedSquare - The square that is been clicked by the user.
                player - wich player click the square.         
         */
        markMove : function(clickedSquare, player)
        {
            //Put the letter associated with this player("X" or "O") in a text actor of clutter
            let letterToDraw = new Clutter.Text( {"text":player, "color":OX_TEXT_COLOR} );
            //Set the font, and size of the text
            letterToDraw.set_font_name("Sans Bold " + OX_FONT_SIZE + "px");
            //Get the position of the rectangle
            let [r_x, r_y] = clickedSquare.get_position();
            let offset_x = (clickedSquare.get_width() / 2) - (letterToDraw.get_width() / 2); 
            let offset_y = (clickedSquare.get_height() / 2) - (letterToDraw.get_height() / 2);

            letterToDraw.set_position(r_x + offset_x, r_y + offset_y);
            letterToDraw.move_anchor_point_from_gravity (Clutter.Gravity.CENTER);

            this.stage.add_actor(letterToDraw);
            /*
             WARNING: The next code is deprecated. Instead of this we have to use a simple
             code. The code of the new version will be:
              actorRectangle.animate(Clutter.AnimationMode.EASE_OUT_ELASTIC, 500,
             "scale-x", 0.5, "scale-y", 0.5, NULL);
             */

            /*
             Create a new timeline as we see in the animation headland(its function it's like the time bar of youtube
              videos) with duration 500ms
             */
            let timeline = new Clutter.Timeline( {'duration':500} );
            /*
             Create a new function to control the timeline and the properties of the actor.
             This will use the ease out elastic type of animation, resulting in a animation that cause the letter
             seems an elastic thing
             */
            let alpha = new Clutter.Alpha ( {'timeline':timeline, 'mode':Clutter.AnimationMode.EASE_OUT_ELASTIC} );
            //Create a new behaviour to the actor. We want that the actor scale to 0.5 of its size.
            let behaviour = new Clutter.BehaviourScale( {'alpha':alpha, 'x_scale_start':1.0, 'y_scale_start':1.0, 
                'x_scale_end':0.5, 'y_scale_end':0.5} );
            //Apply the behaviour to the letter actor
            behaviour.apply (letterToDraw);
            //Start the animation
            timeline.start ();
        },

        show : function()
        {
            //Show the stage and his actors
            this.stage.show();
            //Start our program with the GUI we created
            Clutter.main();
        }
};

//Create our GUI
let view = new BoardView(OX_PLAYERS, OX_SIDE_SIZE);
//Start our GUI
view.show();

}}}

Save this code to a file "Gameosx.js" and to execute the entire game we enter in a terminal:
{{{
gjs-console Gameosx.js
}}}

Tachan! You create a simple game with clutter and javascript. Enjoy!

<<Anchor(knowingClutter-problems)>>
=== Problems ===

''I haven't got Gjs in my software management!''

Install from source:
 * https://live.gnome.org/Gjs
 * https://live.gnome.org/GObjectIntrospection
 * http://www.clutter-project.org/download

[[#index | Go to index]]

<<Anchor(knowingGnomeShell)>>
= Knowing gnome shell =

<<Anchor(knowingGnomeShell-introducing)>>
== Introducing gnome shell ==

GNOME Shell provides core interface functions like switching windows, launching applications or see your notifications.
So gnome shell is "what you see and what you use" to open applications, changing between windows, move between workspaces, see notifications, etc.
Gnome shell is made 50% in c 50% in javascript. You only have to touch the javascript code, because is the code that you can modify for your extension. Maybe, with the pass of the time, the percentage of c code will decrease.
Gnome shell manage the workspace, notifications, windows(how is managed, not the rendering(which is managed by Mutter)), dash, top bar, and lacunh applications.
It uses GPU acceleration. The rendering of the interface is managed by clutter, so gnome shell doesn't touch graphics.
Also, gnome shell doesn't touch css, this is managed by St, we will see what St is.
And, the last thing you have to know is that gnome shell, currently, is not using the animation framework of clutter(because when gnome shell was did the animation framework in clutter was not present), instead, clutter use [[http://hosted.zeh.com.br/tweener/docs/en-us/ | Tweener]]. We'll see an example of tweener in [[#myFirstExtension | My first extension]] headland.

Gnome shell has these parts:

{{attachment:gnomeShellParts.png}}

{{attachment:gnomeShellOverviewParts.png}}

<<Anchor(toReview-6)>>
Also, when programming a extension, if you modify the code '''~+you have to restart gnome shell+~'''. To do this pres ALT+F2 and put "r" and enter

Sometimes gnome shell crash because your extension touch something wrong. To return to normally, press CTRL+ALT+F2 and put 

{{{
DISPLAY=:0 gnome-shell
}}}

and press enter.

Then press CTRL+ALT+F7 or CTRL+ALT+F8 and you will go to a new gnome-shell interface.

Note: if something crash you can go again to CTRL+ALT+F2 and see the error, and do the same to start a new gnome shell.

Also, maybe gnome shell doesn't crash but is inresponsible.

To fix it, press CTRL+ALT+F2 and then

{{{
ps -e | grep gnome-shell
}}}
with this list all the proccess that have gnome-shell in the name.
Then, you see a number, called PID, and at the rigth gnome-shell. So, get this PID and
{{{
kill -9 "the PID that you get above"
}}}
With this you stop the procces you wrote with his PID.

An example:
{{{
carlos@carlos-pc-fedora ~$ ps -e | grep gnome-shell
 1174 ?        00:18:29 gnome-shell
 1276 ?        00:00:00 gnome-shell-cal
carlos@carlos-pc-fedora ~$ kill -9 1174
}}}

[[#index | Go to index]]

<<Anchor(knowingGnomeShell-interactionWithClutter)>>
== Interaction with clutter ==

How gnome shell interact with clutter?
Basically gnome shell define a lot of actors. As we saw above, each object in the GUI, like the "top bar", the "message tray", etc are actors.
So gnome shell implements its behaviour. I mean, gnome shell define how the actors have to move, how to interact with the mouse, how to interact with other actors, etc. This is the main function of gnome shell. So the interaction with clutter is by the actors and all of its functions, behaviours, animations etc.

[[#index | Go to index]]


<<Anchor((knowingJavascript-Gjs))>>
== Gjs and how to use c API gnome libraries from javascript ==

Gjs is the library that allows you to use c libraries of gnome(in fact, almost all libraries of gnome are written in c) from javascript using GObject-introspection. GObject-introspection is a technique to allow developers to easily build bindings that allows you to use the c libraries from other computer languages like javascript, python, etc.
You have not worry about it, except that when you need to use a function from some gnome librarie, the documentation is written
for the C language. So you "don't know" exactly how your function is called if you want to use it from javascript.

But, there are some rules for map the c API to javascript, so, reading the c API reference you can know how the function
you want to use is called in javascript.
In this page you have the rules that you have to follow to know how the function you want to use is called:
https://live.gnome.org/Gjs/Mapping

So, for example, if we are doing some extension, and we want to create a button in the top bar of gnome-shell
we go to the API reference of St in http://developer.gnome.org/st/stable/ and we look for a StBin, see http://developer.gnome.org/st/stable/StBin.html

Fist we see that the class(c struct) is called StBin, so, I guess that the class in javascript is called St.Bin, so for create a new
StBin we do
{{{!# java
St.Bin()
}}}

But, we also can pass to the constructor, as wee saw before in Gjs/Mapping webpage, a properties map. Wich properties can we pas to the cosntructor? All of the object hierarchy. So if we see into the StBin class we only see a few properties, but if we see at the object
hierarchy headland http://developer.gnome.org/st/stable/StBin.html#StBin.object-hierarchy we also see that StBin is inhereted from
StWidget. So we can use these properties also in the cosntructor. So for example we can do the next StBin call:

{{{!# java
button = new St.Bin({ style_class: 'panel-button',
                    reactive: true,
                    can_focus: true,
                    x_fill: true,
                    y_fill: false,
                    track_hover: true });
}}}

Here we are modifying properties from StBin and also from StWidget(because StBin is inhereted from StWidget). So for example, style_class property comes from StWidget class, and x_fill property comes from StBin class.
The same happens to clutter API, etc.
So now, we know how to interpret c APIs to use into our javascript code.



[[#index | Go to index]]

<<Anchor(knowingGnomeShell-API)>>
== API ==

Apuf....this is very difficult, because of the lack of documentation...So the best way is to see the code (Yes, the best way...the only way!).
To make you more easy this step, I did a diagram explaining wich classes have what objects and I will explain you in overview each interesting component.

I recommend you to take a coffe, ten minute break... :)

After coffe, now see the diagram:

{{attachment:gnomeShellDiagram.bmp}}

To understand the diagrama, think that this is a "contingency" diagram, I mean, it show you the imports of each file. So, if Main imports Overview,
is because Main will use Overview.

It's a hierachical diagram, so we have level 0 with Main, level 1,...level 6. The level 0 is Main, wich is a file and also a class inside the file, so if we see the Main.js file we will see that it contains a class, called Main.

Also, Main imports Overview.js, Panel.js....etc. Each of these files contains some classes, but, the most of these files, contains a class named equal as the file. So we have Overview.js and inside we have Overview class and ShellInfo class.

In the most cases, the class that imports some file use the class named equal as the file imported. So, for example, Main imports Overview.js and Main uses and preserve an object from the class Overview (wich is defined in Overview.js file). So, we have Main.overview as an instance.

Normally, the attributes of a imported class is preserved as the name of the class in lower case, or, if the attribute is private, with an underscore. For example, we have Main.overview._dash.

In the diagram, the exemple above will be Main->Overview(file)->Overview(class) wich the instance is preserved in Main as "overview" -> Dash(file) -> Dash(class) wich the instance is preserved in overview as _dash.

As you can see, the most attributes of some class is the main class of a file (called equal to the file) uderscored or lower cased.

Now, we we'll see a brief explanation of each level, group, class, etc.
I will put in bold the objects and libraries I consider most frequently used when we do an extension and in violet colour in the diagram. So I recommend you to only see these now, and after doind some extension example, you can go back here and see the other classes, wich are very interesting and defines very useful things of the entire gnome platform.

[[#index | Go to index]]

=== Class explanation ===
'''Warning''': a better documentation for the API is here: http://mathematicalcoffee.blogspot.com.es/2012/09/gnome-shell-javascript-source.html .
We are working together to embed the documentation here. Until this arrive, I recommend to see her post instead of the next class explanation.

The only reason you may have to see the next class explanation is that the diagram is correlated with it

 * MainUI 
  This is the main objects we will touch and rewritte to make our extension
  * '''Overview''': This object have all we see normally when we are in the "Activities" headland. So, it has  the dash, the workspaces, the window actors, the search bar, the display apps, etc.
   * Dash: This is the bar that you have at the left in overview.
   * !WorkspaceView: This class manage all workspaces, it means, the workspaces placed at rigth and also the windows running. So if we want to change how the windows are shown in the overview(i.e. order the windows like KDE or Mac) we have to look into this.
   * !ViewSelector: This is the selector for "Windows" and "Applications" tabs.
   * !AppDisplay: This is the selector of all aps when you click "Applications" in the ViewSelector
  * '''!MessageTray'''
   This is the object at the bottom, where your notifications are showed
   * Notification: Is the instance of one notification (icon, text, banner, etc)
   * !MessatreTray: The instance of the message tray
   * Source: The application source of one or more notifications. Source provides the icon, the access to the application assigned to the notification, etc.
   * !SystemNotificationSource: Define a system source. It is inherit from Source.
   * !SummaryItem: This is the item with the icon and text in the message tray representing one notification source.   
   * !FocusGrabber: Grab and control the focus for the message tray. We need this because the focus acts diferently depending of the siutation for the message tray.
   * !URLHighlighter: This highligh the urls in the messages when you are talking with someone.
  * '''Panel'''
  This is the top panel
   * Panel: It's the instance of the panel.
   * !ActivitiesButton: Is the button of "Activities". Extend PanelMenu.Button. All the others icons in the panel are PanelMenu.Button
   * !AnimatedIcon: Generate a animated icon (this is used for the "waves" when you reach the hot corner of the panel)
   * !AppMenuButton: This class manages the "application menu" component that appears when you do rigth click over the appliction name in the panel.
   * !PanelCorner: It's the hot corner that activate the overview.
   * !TextShadower: Generate the shadow of the texts
  * !CtrlAltTab: Implements the UI of the ctrl+alt+tab function.  
  * Layout: This manages the shell "chrome"; the UI that's visible in the normal mode (ie, outside the Overview), that surrounds the main workspace content.
  
 * C libraries 
  All of these are libraries written in c. We doesn't rewritte these libraries to implement an extension. The main library we will probably use is St.
  * '''St''': This is the unique library will be use for the GUI. It is made in c, using clutter. Manage the css theme of gnome shell and implements useful actors like buttons, text prompts, etc. See http://developer.gnome.org/st/stable/ to see the avaiable actors as buttons, text labels, etc.
  * Gio: This library allows you to acces to the filesystem easily. http://developer.gnome.org/gio/stable/ch01.html
  * GLib: It is a general-purpose utility library, which provides many useful data types, macros, type conversions, string utilities, file utilities and a mainloop abstraction. http://developer.gnome.org/glib/2.32/glib.html
  * Mainloop: Provide listen events. This is the GTK+ event listener. Gnome shell use this mainloop and the clutter one.
  * Shell: Implements some functions that gnome shell in javascript can't implements, like the screenshot or the desktop recorder.
  * Meta: It's the window manager. It is called Mutter. Is a window manager based on clutter.
  * GDK: An intermediate layer which isolates GTK+ from the details of the windowing system.
  * Clutter: What's this?? It's not familiar to me... :P Remember that it is write in c, but it use GObjectIntrpospection, so we can use clutter directly in javascript(or other programming languages that support GObjectIntrospection) as we saw in [[#knowingClutter-introducingClutter | Knowing clutter]]

 * General utils 
  Some util classes that gnome shell use.
  * Magnifier: It is a accessibility tool, that allow to deficient users to see the desktop with zoom
  * !TelephatyClient: Manage the chat, IRC, videocalls, audicalls, etc. in gnome shell interface. So, when some person talk us and we see the chat in the message tray, it is because telepathy client are doing his work.
  * !LookingGlass: Tool for helo developers developing gnome shell and gnome shell extensions.
  * !PlaceDisplay: Represents a place object, which is most normally a bookmark entry, a mount/volume, or a special place like the Home Folder, Computer, and Network.
  * Keyboard: Manage and define the keyboard events, etc. for gnome shell.
  
 * UIManagersAndHandlers
  * !XdndHandler: Handle the drag and drop (DND) function of gnome shell.
  * !WindowManager: Manage the windows behaviour in gnome shell, like wich window is in the top stack of showing, the dimm of one window, etc.
  
 * Prompts 
  Contains all the prompts you see in gnome shell, like when you try to install some applicaton (!PolkitAutheticantionPromt) or when you connect some mass storage device to computer and a prompt telling you what to do is shown.
  * !RunDialog: This is the dialog shown when you press Alt+F2.
  * !NotificationDaemon: Manage all notifications. It is a class under !TelephatyClient, etc. Telephaty client send him some data, and the !NotificationDaemon filter it and acts accordingly.
  * !EndSessionDialog: The prompt shown when you click on "power off" or "log out"
  * !KeyringPrompt: It is the prompt shown when the system ask you about a password, like when you connect to a new wifi channel.
 
 * Util not touch 
  I called this group as "util not touch" because it agrouped some classes that, in principle, you won't change to do an extension.
  I said in princyple, because you can change whatever you want (If the extensions validators people are agree)
 <<Anchor(toReview-7)>>
  * ShellDBus: '''~+ This is an abstracition layer that allows other applications to interact with shell. For example, when you install or uninstall an extension by extensions.gnome.org, this class is called.+~'''
  * Environment: Initialize some variables for gnome shell environment, like Tweener.
  * !NetworkAgent: Manage network (wifi, wire, bluethoot) interface.
  * !StatusIconDispatcher: Dispatche icons for the status bar
  * Scripting:  This module provides functionality for driving the shell user interface in an automated fashion. The primary current use case for this is automated performance testing, but it could be applied to other forms of automation, such as testing for correctness as well.
  * !WindowAttentionHandler: Manage the "x is ready" dialog you got when you click to run some application and other things like this. It define when a window is requesting attention from the user.
  * !ExtensionSystem: Manage the extensions
  * !PolkitAuthenticationAgent: Manage the authentication for administrator actions, like when you install an application.
  * !AutorunManager: Manage the autorun function, like when you insert some device in the computer and a dialog asking what to do shown.
  * !AutomounManager: Manage the automount of devices, like when you insert a USB stick and it is mounted automatically.

[[#index | Go to index]]

<<Anchor(lookingGlass)>>
= Looking glass =

This is the tool for debug gnome shell and javascript code for gnome shell.
To open it do Alt+F2 and type lg. Then a window overlapping all appears.
Looking glass is divided into tabs: Evaluator, Windows, Memory and Extensions.
The main view is "Evaluator". Here you can evaluate random code of javascript, accesing gnome shell objects and libraries.
For example, write this in the evaluator and press enter:
{{{#!java
Main.notify("Hello world")
}}}
Then, you can see that you acces to the Main object and you call the "notify" function that generate a transient notification. So as you can see, you can evaluate random code and acces all the objects and libraries(clutter, St, Glib, etc) of gnome shell.

Also, in the Evaluator tab, you have a "picker". Do you see a "cuentagotas" at left corner of looking glass? Click into it. Then you can "pick" random object of the interface of gnome shell and know its name. This is useful if you are trying to know "where" is the object you are seeing in the class hierarchy of gnome shell and wich kind of object is.

In the Windows tab, you can see wich windows are currently active. Pay attention to wmclass. This name let you identify a application inside gnome.


The Extensions tab tell you wich extensions are installed and some other information about each extension. If some extension reach an error, the error will be displayed there (this is not always true, sometimes, the error is not displayed there and you have to see the ~.xsession-errors file to see if some error ocurred).

[[#index | Go to index]]

<<Anchor (myFirstExtension)>>
= My first extension =
Finally! Now, we do our first simple extension, a simple hello world.
For do that, we use a gnome tool for do extensions called "gnome-shell-extension-tool".
Then, to do your first extension put in a terminal:
{{{
gnome-shell-extension-tool --create-extension
}}}

Then you are asked about the name of your application. For this extension we put "Hello world" and press enter.

Then you are asked about a description. Put something like: Show a hello world label pressing an icon in the system tray.

Then you are asked about an uuid. This is a globally-unique identifier for your extension. For choose a good uuid gnome recomend something related about your email. For example, if your email are first.second1925@server.com I recommend something like theNameOfYourExtension@first.second1925-server.com

In that case, we write helloWorld@email.com and press enter.

Tada! The code of the main file is show in gedit.

Before see into the code, we'll active the extension to test it and see what happens. To active it, we have to go to gnome-tweak-tool (aka advanced settings) (if you didn't install it, install now from your software manager. Search for gnome-tweak-tool).
Then in gnome-tweak-tool go to "Shell extensions" and turn on your extension (If is not shown, press alt+f2 and put 'r' without quotes and press enter to restart the shell and force to load all extensions).

Now, do you see in the system tray a new icon with a gears shape? click into it and you can see how your extensions tell you "Hello, world!".

Analize this visualy. You see an icon into the system tray. Also, when you click it, you see a label and this label has an animation(from opacity 100% to opacity 0%). Now, we'll see in the code how it is defined.

To see the code of your extension and edit it you have to know where is it. It is in "~/.local/share/gnome-shell/extensions/" and there are all extensions, including your new extension "helloWorld@email.com" folder.
Go to your extension folder, and you'll see a extension.js, a metadata.json and a stylesheet.css

extension.js is your extension code in javascript. Don't change the name, each extension has to has a extension.js file to work.

metadata.json is the file that holds your context about your extension, like your extension uuid, name, description, etc. If you don't know what is JSon see http://www.json.org/ . Basically is a tool/language to preserve some data of our program between executions.

stylesheet.css is the file where the style of your UI objects are defined (for example the style of the "Hello, world!" label. You can change the font, the background color, the corner radius, etc.)
It use CSS theming, if you don't know what is CSS technology see http://www.w3schools.com/css/ . The common use is for make webpages. It works together with HTML technology to create webpages, but now it is used for a bunch of diferent things. It is a standard to do things related with themes and visual appearance.
This file is optional, because maybe your extension doesn't use UI object that needs custom styles.

Now you know wich files is needed for a extension, but you don't know how a extension is structured, so I do you a brief explanation:

The extension has three must-to-be functions. init(), enable() and disable().

Don’t do anything major in init()

init() is there to have anything that needs to happen at first-run, like binding text domains. Do not make any UI modifications or setup any callbacks or anything in init(). Your extension will break, and gnome-developers will reject it. Do any and all modifications in enable().
Undo all UI modifications in disable()

If you make any UI modifications in enable(), you need to undo them in disable(). So, if you add an icon to the top bar when your extension is enabled, you need to remove it. Simple. Failure to do so will be an immediate rejection.
Remove all possible callback sources.

If you’re writing an extension, you must disconnect all signals and remove all Mainloop sources. Failure to do so will be an immediate rejection. So, if you connect to a signal using global.display.connect('window-created', onWindowCreated);, you need to disconnect it in this manner:

{{{#!java
let _windowCreatedId;
 
function enable() {
    _windowCreatedId = global.display.connect('window-created', onWindowCreated);
}
 
function disable() {
    global.display.disconnect(_windowCreatedId);
}
}}}
The same goes for any timeouts or intervals added with the Mainloop module. Use Mainloop.source_remove to make sure your source is removed.

Maybe you don't understand what the mainloop is, etc. but at least, you know that these are the rules, and we have to satisfy these rules.
In some time, when we do some more complicated extensions and we use callbacks, signals, the mainloop, inject code, etc. we need to 
remember these rules.

See: http://blog.mecheye.net/2012/02/requirements-and-tips-for-getting-your-gnome-shell-extension-approved/

Once we know the rules, go to see into the code of the "hello world" extension.

Go to your favorite IDE (Anjuta, Eclipse or even gedit) and open the file extension.js. Then you can see the code of your "hello world" extension.

The code is not commented, so I commented carefully the code to understand it better for a begginer.

This is the code commented:
{{{#!java

/*In this example we will be click a button in the top bar,
  causing an event that create a text label (hello world), which with some
  animation, will be decreasing its opacity from 100% to 0%
 */


/*Import St because is the library that allow you to create UI elements*/
const St = imports.gi.St;
/*
  Import Main because is the instance of the class that have all the UI elements
  and we have to add to the Main instance our UI elements
  */
const Main = imports.ui.main;
/*Import tweener to do the animations of the UI elements*/
const Tweener = imports.ui.tweener;

/*Global variables for use as button to click (button) and a text label.*/
let text, button;

/*
  Function to call when the label is opacity 0%, as the label remains as a
  UI element, but not visible, we have to delete it explicitily. So since
  the label reaches 0% of opacity we remove it from Main instance.
 */
function _hideHello() {
    Main.uiGroup.remove_actor(text);
    text = null;
}

function _showHello() {
	/*if text not already present, we create a new UI element, using ST library, that allows us
	  to create UI elements of gnome-shell.
	  REFERENCE: http://developer.gnome.org/st/stable/
	 */
    if (!text) {
        text = new St.Label({ style_class: 'helloworld-label', text: "Hello, world!" });
        Main.uiGroup.add_actor(text);
    }
    
    text.opacity = 255;
    
    /*
      we have to choose the monitor we want to display the hello world label. Since in gnome-shell
      always has a primary monitor, we use it(the main monitor)
     */
    let monitor = Main.layoutManager.primaryMonitor;

    /*
     we change the position of the text to the center of the monitor.
     */
    text.set_position(Math.floor(monitor.width / 2 - text.width / 2),
                      Math.floor(monitor.height / 2 - text.height / 2));

    /*And using tweener for the animations, we indicate to tweener that we want
      to go to opacity 0%, in 2 seconds, with the type of transition easeOutQuad, and,
      when this animation has completed, we execute our function _hideHello.
      REFERENCE: http://hosted.zeh.com.br/tweener/docs/en-us/
     */
    Tweener.addTween(text,
                     { opacity: 0,
                       time: 2,
                       transition: 'easeOutQuad',
                       onComplete: _hideHello });
}

/*This is the init function, here we have to put our code to initialize our extension.
 we have to be careful with init(), enable() and disable() and do the right things here.
 REFERENCE: http://blog.mecheye.net/2012/02/requirements-and-tips-for-getting-your-gnome-shell-extension-approved/
 */
function init() {
	/*
	  We create a button for the top panel. We pass to the constructor a map of properties, properties from St.bin and its
	  parent classes, like stWidget. So we declare this properties: a style class(from css theming of gnome shell), we made it reactive
	  so the button respond for the mouse clicks, we made it that can focus, so marks the button as being able to receive keyboard focus 
	  via keyboard navigation, we made the button to fill the x space, and we don't want to fill the y space, so we set the values trues and false respectively
	  and we want that the button be reactive to the hover of the mouse, so we set the value of the track_hover property to true.
	 */
    button = new St.Bin({ style_class: 'panel-button',
                          reactive: true,
                          can_focus: true,
                          x_fill: true,
                          y_fill: false,
                          track_hover: true });
    /*
      We create an icon with the system-status-icon icon and give it the name "system-run"
     */
    let icon = new St.Icon({ icon_name: 'system-run',
                             style_class: 'system-status-icon' });
    /*
      we put as a child of the button the icon, so, in the structure of actors we have the icon inside the button that is a
      container.
     */
    button.set_child(icon);
    /*
      we connect the actor signal "button-press-event" from the button to the funcion _showHello. In this manner,
      when we press the button, this signal is emitted, and we captured it and execute the _showHello function.
      You can see all signals in the clutter reference(because we are using St that implements actors from clutter, and
      this signals comes from the actor class): http://developer.gnome.org/clutter/stable/ClutterActor.html#ClutterActor.signals
     */
    button.connect('button-press-event', _showHello);
}

/*
  We have to write here our main extension code and the things that actually make works the extension(Add ui elements, signals, etc).
 */
function enable() {
	/*
	  We add the button we created before to the rigth panel of the top panel (where the sound and wifi settings are)
	 */
    Main.panel._rightBox.insert_child_at_index(button, 0);
}

/*We have to delete all conections and things from our extensions, to let the system how it is before our extension. So
 We have to unconnect the signals we connect, we have to delete all UI elements we created, etc.
 */
function disable() {
	/*
	 we remove the button from the right panel
	 */
    Main.panel._rightBox.remove_child(button);
}

}}}

[[#index | Go to index]]

<<Anchor(allCode)>>
= All code to download or modify =
If you want all the code. images, and the wiki code posted in this wiki, you can donwload using git from here

https://github.com/csoriano89/StepByStepTutorial

Also, if you want to modify something, fix something or add some code to the wiki, I appreciated you if you use the git repository above and change the wiki after. If we do this in this manner we can have a repository with all the code to download and everything update.
